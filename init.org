#+TITLE: Emacs configuration
#+PROPERTY: header-args :tangle ./init.el

* Introduction
  :PROPERTIES:
  :tangle:   no
  :END:

  Here is the source of my Emacs configuration. Create the files by
  running ~org-babel-tangle~ (~C-c C-v t)~ in this file.

* Emacs setup

  In this section, I keep track of the way I install Emacs on various
  environments.

** Elementary

   Download the tar sources, then

   #+BEGIN_SRC sh :tangle no
   ./configure --with-modules --with-x-toolkit=lucid --with-xwidgets
   make
   sudo make install
   #+END_SRC

** Mac OS

   #+BEGIN_SRC sh :tangle no
     brew install libxml2 gnutls texinfo
     export PKG_CONFIG_PATH="/usr/local/opt/libxml2/lib/pkgconfig"
     git clone -b master git://git.sv.gnu.org/emacs.git
     cd emacs
     sh autogen.sh
     ./configure --with-gnutls --with-librsvg --with-cocoa --with-modules
     make
   #+END_SRC

* Package management

** Initialiaze package

   I want to download packages from [[https://melpa.org/][MELPA]] too

   #+BEGIN_SRC emacs-lisp
     (eval-and-compile
       (require 'package)
       (add-to-list 'package-archives (cons "melpa" "https://melpa.org/packages/") t))
   #+END_SRC

   The only remaining thing to do is initializing the package manager

   #+BEGIN_SRC emacs-lisp
     (package-initialize)
   #+END_SRC

** use-package

   All my configuration is based on [[https://github.com/jwiegley/use-package][use-package]] and [[https://github.com/quelpa/quelpa][quelpa]]. These
   packages have to be initialized  at the very beginning.

   #+BEGIN_SRC emacs-lisp
     (eval-and-compile
       (let ((packages-to-install '(use-package quelpa-use-package)))
       (dolist (package packages-to-install)
	 (unless (package-installed-p package)
	   (package-refresh-contents)
	   (package-install package))))

       (require 'use-package))
   #+END_SRC

   Always install a package declare with ~use-package~ if it's not
   installed:

   #+BEGIN_SRC emacs-lisp
     (setq use-package-always-ensure t)
   #+END_SRC

   Additionally, we will require ~quelpa-use-package~ right now so
   that we don't have to care about that later.

   #+BEGIN_SRC emacs-lisp
     (require 'quelpa-use-package)
   #+END_SRC

** Backups

   elpa-backup is a personal package located at [[file:site-lisp/elpa-backup.el][site-lisp/elpa-backup.el]]

   It has 2 commands:
   - ~elpa-backup-do~, to create a snapshot of the ~elpa~ directory
   - ~elpa-backup-rollback~, to replace the current ~elpa~ directory
     with the snapshot

   Running ~elpa-backup-do~ before an update ensures I can come back
   to a working state if something goes wrong.

   #+BEGIN_SRC emacs-lisp
     (use-package elpa-backup
       :ensure nil
       :commands (elpa-backup-do elpa-backup-rollback))
   #+END_SRC

* Theme
** Default settings

   Remove GUI garbage and increase the font size.

   #+BEGIN_SRC emacs-lisp
     (tool-bar-mode 0)
     (scroll-bar-mode 0)
     (menu-bar-mode 0)
     (set-face-attribute 'default nil :height 140 :family "Source code pro")
   #+END_SRC

** Gruvbox

   #+begin_src emacs-lisp
     (use-package gruvbox-theme
       :config (load-theme 'gruvbox-dark-soft :no-confirm))
   #+end_src

** Mode line
*** Theme

    Make the mode line the same colors than the whole buffer.

    #+begin_src emacs-lisp
      (set-face-attribute 'mode-line nil :background nil :foreground "white")
      (set-face-attribute 'mode-line-inactive nil :background nil :foreground "dim gray")
    #+end_src

*** Mode line flycheck reporting

    This is a simple widget to show flycheck errors and warnings in the
    mode line.

    #+BEGIN_SRC emacs-lisp
      (defface my-flycheck-mode-line-font
	'((t :height 120 :weight bold))
	"Base face for showing flycheck errors adn warnings in the mode line."
	:group 'mode-line)

      (defface my-flycheck-mode-line-error-disabled
	'((t :inherit my-flycheck-mode-line-font :foreground "red3"))
	"Face for showing no flycheck errors in the mode line."
	:group 'mode-line)

      (defface my-flycheck-mode-line-error
	'((t :inherit my-flycheck-mode-line-font :foreground "red1"))
	"Face for showing flycheck errors in the mode line."
	:group 'mode-line)

      (defface my-flycheck-mode-line-warning-disabled
	'((t :inherit my-flycheck-mode-line-font :foreground "orange3" ))
	"Face for showing no flycheck warnings in the mode line."
	:group 'mode-line)

      (defface my-flycheck-mode-line-warning
	'((t :inherit my-flycheck-mode-line-font :foreground "orange1" ))
	"Face for showing flycheck warnings in the mode line."
	:group 'mode-line)

      (defface my-flycheck-mode-line-info-disabled
	'((t :inherit my-flycheck-mode-line-font :foreground "green4" ))
	"Face for showing no flycheck warnings in the mode line."
	:group 'mode-line)

      (defface my-flycheck-mode-line-info
	'((t :inherit my-flycheck-mode-line-font :foreground "green1" ))
	"Face for showing flycheck warnings in the mode line."
	:group 'mode-line)



      (defun my-flycheck-get-error-count ()
	"Return the number of flycheck errors by level."
	(interactive)
	(let ((errors flycheck-current-errors)
	      (count-by-level '()))
	  (cl-loop for error in errors
		   for level = (flycheck-error-level error)
		   for new-value = (1+ (or (plist-get count-by-level level) 0))
		   do
		   (setq count-by-level
			 (plist-put count-by-level level new-value))
		   finally return count-by-level)))

      (defun my-flycheck-mode-line ()
	"Create a mode line element to display flycheck errors."
	(let* ((error-count (my-flycheck-get-error-count))
	       (errors (or (plist-get error-count 'error) 0))
	       (warnings (or (plist-get error-count 'warning) 0))
	       (infos (or (plist-get error-count 'info) 0)))
	  (concat
	   "["
	   (propertize (format "%d" errors)
		       'face (if (= 0 errors)
				 'my-flycheck-mode-line-error-disabled
			       'my-flycheck-mode-line-error))
	   " "
	   (propertize (format "%d" warnings)
		       'face(if (= 0 warnings)
				'my-flycheck-mode-line-warning-disabled
			      'my-flycheck-mode-line-warning))
	   " "
	   (propertize (format "%d" infos)
		       'face(if (= 0 infos)
				'my-flycheck-mode-line-info-disabled
			      'my-flycheck-mode-line-info))
	   "]")))
    #+END_SRC

*** Powerline

    I am using my own theme forked from ~powerline-default-theme~.

    #+BEGIN_SRC emacs-lisp
      (defun my-powerline-theme ()
	"Setup the default mode-line."
	(interactive)
	(setq-default
	 mode-line-format
	 '("%e"
	   (:eval
	    (let* ((active (powerline-selected-window-active))
		   (mode-line-buffer-id (if active 'mode-line-buffer-id 'mode-line-buffer-id-inactive))
		   (mode-line (if active 'mode-line 'mode-line-inactive))

		   (lhs (list (powerline-raw "%*" mode-line 'l)
			      (when (> (length (tab-bar-tabs)) 1)
				(powerline-raw (thread-last (tab-bar-tabs)
						 (assq 'current-tab)
						 (assq 'name)
						 cdr)
					       mode-line 'l))
			      (powerline-buffer-id `(mode-line-buffer-id ,mode-line) 'l)
			      (powerline-raw " " mode-line)
			      (powerline-process mode-line)
			      (powerline-narrow mode-line 'l)
			      (powerline-raw " " mode-line)
			      ))
		   (rhs (list
			 (powerline-vc mode-line 'r)
			 (my-flycheck-mode-line)
			 (unless window-system
			   (powerline-raw (char-to-string #xe0a1) mode-line 'l))
			 )))

	      (concat (powerline-render lhs)
		      (powerline-fill mode-line (powerline-width rhs))
		      (powerline-render rhs)))))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package powerline
	:config
	(setq powerline-default-separator 'bar
	      powerline-display-hud nil)
	(my-powerline-theme))
    #+END_SRC

** Emojis

   ~emojify~ displays ascii emojis using images. This is both prettier
   and faster to render.

   #+begin_src emacs-lisp
     (use-package emojify
       :config (global-emojify-mode))
   #+end_src

* Main script
** Global variables

   These are common useful variables for getting the emacs init dir
   and the path to my personal local packages.

   #+BEGIN_SRC emacs-lisp
     (defconst my-init-dir (file-name-directory (or load-file-name (buffer-file-name))))
     (defconst my-site-lisp (concat my-init-dir "site-lisp/"))
   #+END_SRC

   ~my-site-lisp~ should be added to ~load-path~ as it contains packages.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path my-site-lisp)
   #+END_SRC

** Custom configuration

   Move the custom configuration file outside of the init file to
   avoid blending custom configuration with the init sources.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat my-init-dir "custom-file.el"))
     (load custom-file 'no-error)
   #+END_SRC

** Load the initialization modules

   Load the sources present in the init/ directory. These are sources
   I didn't port to my org setup yet.

   #+NAME: init-modules
   - exec-path-from-shell
   - prompt
   - editing
   - git
   - auto-completion
   - code-checking
   - rocktl
   - emacs-lisp
   - web
   - cucumber

   #+BEGIN_SRC emacs-lisp :var modules=init-modules
     (defun my-load-init-file (file)
       "Load one initialization file.

     FILE is the name of the file without extension and directory."
       (load (concat my-init-dir "init/" (if (listp file) (car file) file) ".el")))

     (mapc #'my-load-init-file modules)
   #+END_SRC
* General UX
** Startup screen

   Use my personal startup file instead of the default one.

   #+begin_src emacs-lisp
     (setq initial-buffer-choice (expand-file-name "welcome.org" my-init-dir))
   #+end_src

** Ivy

   I use [[https://github.com/abo-abo/swiper][ivy]] instead of the basic read interface, because it has a
   good matching system and is lighter than helm.

   Ivy comes with counsel and swiper, that implements a lot of common
   Emacs commands with the Ivy interface.

   ~ivy-use-virtual-buffers~ also includes recent files and bookmarks
   in counsel's buffer list.

   ~enable-recursive-minibuffers~ is not directly related to ivy, but
   I set it up here as most of my interactions with the minibuffer
   goes through ivy. It allows opening a new minibuffer while a
   minibuffer is already opened, which I used at my job for finding
   information on my current task while creating branches, for
   example.

   #+BEGIN_SRC emacs-lisp
     (defun init/setup-ivy ()
       "Setup the ivy package."
       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (setq enable-recursive-minibuffers t))

     (use-package ivy
       :config (init/setup-ivy))

     (use-package counsel
       :after (ivy)
       :config (counsel-mode 1))

     (use-package swiper
       :after (ivy)
       :bind (("C-s" . swiper)))
   #+END_SRC

** Glasses

   #+begin_src emacs-lisp
     (use-package glasses
       :hook (prog-mode . glasses-mode)
       :custom ((glasses-face 'bold)
		(glasses-separate-parentheses-p nil)
		(glasses-original-separator "")
		(glasses-separator "")))
   #+end_src

   #+begin_src emacs-lisp
     (use-package subword
       :hook (prog-mode . subword-mode))
   #+end_src

* Performances

  [[https://github.com/emacsmirror/gcmh][gcmh]] minimizes the interferences of the garbage collector with the
  user's activity. There are more details on the package's page.

  #+BEGIN_SRC emacs-lisp
    (use-package gcmh
      :config (gcmh-mode 1))
  #+END_SRC

* Editing
** French keyboard setup

   I use an AZERTY keyboard, which requires loading ~iso-transl~ to
   support all its keys.

   #+BEGIN_SRC emacs-lisp
     (use-package iso-transl
       :ensure nil)
   #+END_SRC

** Rainbow parentheses

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       ; Necessary for first load, to prevent it being loaded by quelpa
       ; while being inexistant
       :if (locate-library "rainbow-delimiters")
       :hook (prog-mode . rainbow-delimiters-mode))
   #+END_SRC

** Expand region

   #+begin_src emacs-lisp
     (use-package expand-region
       :bind (("C-=" . er/expand-region)))
   #+end_src

* Navigation
** imenu

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c i") #'imenu)
   #+END_SRC

** Treemacs

   [[https://github.com/Alexander-Miller/treemacs][Treemacs]] is a nice tree layout file explorer for Emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package treemacs)
   #+END_SRC

** ripgrep

   Ripgrep is my preferred way to search for occurences in a project
   (just after LSP). It is fast, and [[https://github.com/Wilfred/deadgrep][deadgrep]] offers a really nice
   interface for Emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package deadgrep)
   #+END_SRC

* Project management
** Projectile

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :custom
       (projectile-keymap-prefix (kbd "C-c p"))
       :config (projectile-mode))

     (use-package counsel-projectile
       :after (projectile ivy)
       :config (counsel-projectile-mode))
   #+END_SRC

* Shell
** xterm-color

   [[https://github.com/atomontage/xterm-color][xterm-color]] is a replacement for ansi-color that is faster and has
   more feature.

   Here is the comint / shell-mode configuration

   #+BEGIN_SRC emacs-lisp
     (defun my-remove-ansi-from-comint ()
       "Remove ansi-color from comint filters."
       (setq comint-output-filter-functions
	   (remove 'ansi-color-process-output comint-output-filter-functions)))


     (defun my-shell-mode-config-xterm-color ()
       "Configure xterm-color for shell-mode."
       ;; Disable font-locking in this buffer to improve performance
       (font-lock-mode -1)
       ;; Prevent font-locking from being re-enabled in this buffer
       (make-local-variable 'font-lock-function)
       (setq font-lock-function (lambda (_) nil))
       (setq comint-output-filter-functions
         (remove 'ansi-color-process-output comint-output-filter-functions))
       (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)
       (setq-local comint-terminfo-terminal "xterm-256color"))
   #+END_SRC

   Then, we configure eshell:

   #+BEGIN_SRC emacs-lisp
     (defun my-eshell-before-prompt-xterm-color ()
       "Preserve text properties on eshell prompts."
       (setq xterm-color-preserve-properties t))

     (defun my-eshell-init-xterm-color ()
       "Configure xterm-color for eshell."
       (with-eval-after-load 'eshell
	(add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
	(setq eshell-output-filter-functions
	      (remove 'eshell-handle-ansi-color eshell-output-filter-functions))))

     (defun my-eshell-env-xterm-color ()
       "Setup eshell environment for xterm-color."
       (setenv "TERM" "xterm-256color"))
   #+END_SRC

   And compilation-mode:

   #+BEGIN_SRC emacs-lisp
     (defun my-xterm-color-configure-compilation ()
       "Setup xterm-color in compilation-mode"
       (message "Loading xterm-colors for compilation")
       (with-eval-after-load 'compile
	 (setq compilation-environment '("TERM=xterm-256color"))

	 (add-hook 'compilation-start-hook
		   (lambda (proc)
		     ;; We need to differentiate between compilation-mode buffers
		     ;; and running as part of comint (which at this point we assume
		     ;; has been configured separately for xterm-color)
		     (when (eq (process-filter proc) 'compilation-filter)
		       ;; This is a process associated with a compilation-mode buffer.
		       ;; We may call `xterm-color-filter' before its own filter function.
		       (set-process-filter
			proc
			(lambda (proc string)
			  (funcall 'compilation-filter proc
				   (xterm-color-filter string)))))))))

   #+END_SRC

   Finally, we can import and configure the package:

   #+BEGIN_SRC emacs-lisp
     (defun my-xterm-color-init ()
       "First setup for xterm-color."
       (my-remove-ansi-from-comint)
       ;; (my-eshell-init-xterm-color)
       (my-xterm-color-configure-compilation))

     (use-package xterm-color
       :config (my-xterm-color-init)
       :hook ((shell-mode . my-shell-mode-config-xterm-color)
	      (eshell-mode . my-eshell-env-xterm-color)
	      (eshell-before-prompt . my-eshell-before-prompt-xterm-color)))
   #+END_SRC

** vterm

   #+begin_src emacs-lisp
     (use-package vterm
       :no-require t
       :commands (vterm))
   #+end_src

* Org mode
** Basic configuration
*** Clock table indentation

    The org clock table indents its entries using the LateX symbol
    ~\emsp~, which renders badly in org buffers. I override it with my
    own indent function extracted from [[https://emacs.stackexchange.com/questions/9528/is-it-possible-to-remove-emsp-from-clock-report-but-preserve-indentation][a stackexchange discussion]].

    #+BEGIN_SRC emacs-lisp
      (defun my/org-clocktable-indent-string (level)
        (if (= level 1)
            ""
          (let ((str "+"))
            (while (> level 2)
              (setq level (1- level)
                    str (concat str "--")))
            (concat str "-> "))))
    #+END_SRC

*** Org initialization

    #+BEGIN_SRC emacs-lisp
      (defun my/init-org ()
	;; Override clock table ident function with mine
	(advice-add 'org-clocktable-indent-string :override #'my/org-clocktable-indent-string)

	;; Automatically add syntax coloration on org src blocks
	(setq org-src-fontify-natively t)

	(setq org-hide-emphasis-markers t)

	(org-babel-do-load-languages 'org-babel-load-languages
				     '((shell . t)
				       (sql . t))))

    #+END_SRC

*** Package declaration

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :bind (("C-c o t" . org-todo-list))
       :config (my/init-org))
   #+END_SRC

** Agenda

   #+BEGIN_SRC emacs-lisp
     (use-package org-agenda
       :ensure nil
       :bind (("C-c o a" . org-agenda-list)))
   #+END_SRC

** Clock

   #+BEGIN_SRC emacs-lisp
     (use-package org-clock
       :ensure nil
       :bind (("C-c o j" . org-clock-goto)))
   #+END_SRC

** Capture

   #+BEGIN_SRC emacs-lisp
     (use-package org-capture
       :ensure nil
       :bind (("C-c o c" . org-capture)))
   #+END_SRC

** Async

   #+BEGIN_SRC emacs-lisp
     (use-package ob-async
       :no-require t
       :after (org))
   #+END_SRC

** Issue opening

   Use the package ~org-open-ref~ in order to easily open the redmine
   and gitlab issues.

   #+BEGIN_SRC emacs-lisp
     (use-package org-tracker
       :bind (("C-c r j" . org-tracker-open-issue-at-point)
	      ("C-c r J" . org-tracker-open-current-issue)
	      ("C-c r t" . org-tracker-track-time-at-point))
       :quelpa (org-tracker
		:fetcher github
		:repo "stevenremot/org-tracker"))
   #+END_SRC

* LSP

  Setup the core package

  #+BEGIN_SRC emacs-lisp
    (use-package lsp-mode
      :commands lsp
      :bind (("C-c SPC" . lsp-execute-code-action)))
  #+END_SRC

  Setup ~lsp-ui~ and ~company~:

  #+BEGIN_SRC emacs-lisp
    (use-package lsp-ui
      :commands lsp-ui-mode
      :bind (("M-." . lsp-ui-peek-find-definitions)
	     ("M-?" . lsp-ui-peek-find-references)))
  #+END_SRC

* DAP

  #+BEGIN_SRC emacs-lisp
    (use-package hydra)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package dap-mode
      :after lsp-mode
      :config
      (dap-mode t)
      (dap-ui-mode t)
      (require 'dap-chrome)
      (require 'dap-firefox)
      (global-set-key (kbd "C-c d") #'dap-hydra))
  #+END_SRC

* Javascript
** Node modules support

   ~add-node-modules-path~ automatically adds the node_modules bin
   folder to the path. This allows using the project tools when
   opening a file (ex: eslint, prettier).

   #+BEGIN_SRC emacs-lisp
     (use-package add-node-modules-path
       :hook ((js-mode . add-node-modules-path)
	      (typescript-mode . add-node-modules-path)))
   #+END_SRC
** LSP

   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :hook ((js-mode . lsp)))
   #+END_SRC

   Rebind some js-mode keys to lsp:

   #+BEGIN_SRC emacs-lisp
     (use-package js
       :bind (:map js-mode-map
		   ("M-." . lsp-find-definition)
		   ("M-?" . lsp-find-references)))
   #+END_SRC

** Typescript

   Setup the basic typescript-mode:

   #+BEGIN_SRC emacs-lisp
     (use-package typescript-mode
       :mode "\\.tsx?\\'"
       :config (flycheck-add-mode 'javascript-eslint 'typescript-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :hook (typescript-mode . lsp)
       :init (eval-after-load 'lsp-ui '(flycheck-add-next-checker 'lsp 'javascript-eslint)))
   #+END_SRC

** JSON

   #+BEGIN_SRC emacs-lisp
     (use-package json-mode)
   #+END_SRC

** NVM

   Setup the correct node version when opening a JS file.

   #+BEGIN_SRC emacs-lisp
     (defun my-nvm-use-for ()
       (interactive)
       (condition-case error
	   (nvm-use-for-buffer)
	 (t (message "NVM error: %s" error))))

     (use-package nvm
       :hook ((js-mode json-mode typescript-mode dired-after-readin magit-mode) . my-nvm-use-for))
   #+END_SRC

** Swagger

   Setup a custom command to be able to edit yaml in multi-line comments.

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-comment
       :ensure nil
       :after (typescript-mode)
       :bind (:map js-mode-map
	      ("C-c y" . yaml-comment-edit-at-point)
	      :map typescript-mode-map
	      ("C-c y" . yaml-comment-edit-at-point)))
   #+END_SRC

** Prettier

   Enable prettier formatting at save for all the web files.

   #+begin_src emacs-lisp
     (use-package prettier-js
       :hook ((js-mode . prettier-js-mode)
	      (typescript-mode . prettier-js-mode)
	      (web-mode . prettier-js-mode)
	      (css-mode . prettier-js-mode)))
   #+end_src

* PHP
** php-mode

   #+BEGIN_SRC emacs-lisp
     (use-package php-mode
       :mode "\\.php\\'")
   #+END_SRC

** lsp-php

   This package requires [[https://github.com/felixfbecker/php-language-server][php-language-server]] to work. Follow the
   instructions on the readme to do so.

   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :hook ((php-mode . lsp)))
   #+END_SRC
* Docker
** dockerfile-mode

   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode)
   #+END_SRC

** docker

   #+BEGIN_SRC emacs-lisp
     (use-package docker)
   #+END_SRC
* Ocaml / Reason
** Tuareg

   This is the major mode to edit Ocaml buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package tuareg
       :mode ("\\.ml\\'" . tuareg-mode))
   #+END_SRC

** Reason mode

   ~reason-mode~ has a nice auto-formatting feature we can trigger
   before saving a buffer.

   #+BEGIN_SRC emacs-lisp
     (defun init/setup-reason-buffer ()
       "Setup a buffer for working with reason."
       (add-hook 'before-save-hook #'refmt-before-save)
       (setq-local indent-line-function #'indent-relative)
       (lsp))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package reason-mode
       :hook ((reason-mode . init/setup-reason-buffer))
       :mode ("\\.re\\'" . reason-mode))
   #+END_SRC

** LSP

   This package requires [[https://github.com/jaredly/reason-language-server][reason-language-server]] to be installed
   somewhere.

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package lsp-reason
       :ensure nil
       :hook (reason-mode . lsp))
   #+END_SRC

* Markdown

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode)
  #+END_SRC

* YAML

  #+BEGIN_SRC emacs-lisp
    (use-package yaml-mode)
  #+END_SRC

* Java

  Setup lsp-java for editing Java files.

  #+BEGIN_SRC emacs-lisp
    (use-package lsp-java
      :after lsp
      :hook ((java-mode . lsp)))
  #+END_SRC

* Android
** Helpers

   #+BEGIN_SRC emacs-lisp
     (use-package adb
       :ensure nil
       :commands (avd-start-emulator))
   #+END_SRC

** Groovy

   This is useful for editing gradle files.

   #+BEGIN_SRC emacs-lisp
     (use-package groovy-mode)
   #+END_SRC
* TRAMP

  Make sure the remote PATH will be properly set when connecting with
  tramp on SSH:

  #+BEGIN_SRC emacs-lisp
    (with-eval-after-load 'tramp
      (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
  #+END_SRC

* Elm

  #+BEGIN_SRC emacs-lisp
    (use-package elm-mode
      :init
      (setq elm-format-on-save t))

    (use-package company
      :config
      (add-to-list 'company-backends 'company-elm))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package flycheck-elm
      :after (elm-mode flycheck)
      :hook (flycheck-mode . flycheck-elm-setup))
  #+END_SRC

* Rust

  #+BEGIN_SRC emacs-lisp
    (use-package rust-mode
      :mode ("\\.rs\\'" . rust-mode)
      :config (add-hook 'rust-mode-hook #'lsp))
  #+END_SRC

* Vagrant

  #+BEGIN_SRC emacs-lisp
    (use-package vagrant-tramp
      :quelpa (vagrant-tramp
	       :fetcher github
	       :repo "stevenremot/vagrant-tramp"
	       :files ("*.el" ("bin" "bin/vagrant-tramp-ssh"))))
  #+END_SRC

* Gettext

  #+BEGIN_SRC emacs-lisp
    (use-package po-mode)
  #+END_SRC

* Project libs

  Load project libraries that are in the ~projects~ folder. These are
  not committed as it depends on the machine.

  #+BEGIN_SRC emacs-lisp
    (let ((projects-dir (concat my-site-lisp "projects/")))
      (message projects-dir)
      (dolist (lib (directory-files projects-dir t "\.el$"))
	(load-file lib)))
  #+END_SRC

* C++
** LSP

   Setup lSP for C++.

   In order to be able to use it, clangd must be installed:

   #+begin_src sh :tangle no
     sudo apt install clangd-9
   #+end_src

   The ~lsp-clients-clangd-executable~ variable may have to be changed
   from ~"clangd"~ to ~"clangd-9"~.

   #+begin_src emacs-lisp
     (defun my-configure-c++-checkers ()
       (flycheck-add-mode 'lsp 'c++-mode)
       (lsp))

     (use-package cc-mode
       :hook ((c++-mode . my-configure-c++-checkers))
       :config
       (add-to-list 'flycheck-disabled-checkers 'c/c++-clang)
       (add-to-list 'flycheck-disabled-checkers 'c/c++-gcc))
   #+end_src

* Local variables

# Local Variables:
# after-save-hook: (lambda () (org-babel-tangle) (byte-compile-file "./init.el"))
# End:
