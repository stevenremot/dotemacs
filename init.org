#+TITLE: Emacs configuration
#+PROPERTY: header-args :tangle ./init.el

* Introduction
  :PROPERTIES:
  :header-args: :tangle no
  :END:

  Here is the source of my Emacs configuration. Create the files by
  saving by calling [[elisp:(compile "make setup")][make setup]].

* Emacs setup

  In this section, I keep track of the way I install Emacs on various
  environments.

** Elementary

   Download the tar sources, then

   #+BEGIN_SRC sh :tangle no
   ./configure --with-modules --with-x-toolkit=lucid --with-xwidgets
   make
   sudo make install
   #+END_SRC

** Mac OS

   #+BEGIN_SRC sh :tangle no
     brew tap railwaycat/emacsmacport
     brew install emacs-mac --with-xwidgets --with-natural-title-bar --with-librsvg
     ln -s /usr/local/opt/emacs-mac/Emacs.app ~/Applications
   #+END_SRC

* Package management
** elpaca

#+begin_src emacs-lisp
  (defvar elpaca-installer-version 0.2)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
				:ref nil
				:files (:defaults (:exclude "extensions"))
				:build (:not elpaca--activate-package)))
  (when-let ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
	     (build (expand-file-name "elpaca/" elpaca-builds-directory))
	     (order (cdr elpaca-order))
	     ((add-to-list 'load-path (if (file-exists-p build) build repo)))
	     ((not (file-exists-p repo))))
    (condition-case-unless-debug err
	(if-let ((buffer (pop-to-buffer-same-window "*elpaca-installer*"))
		 ((zerop (call-process "git" nil buffer t "clone"
				       (plist-get order :repo) repo)))
		 (default-directory repo)
		 ((zerop (call-process "git" nil buffer t "checkout"
				       (or (plist-get order :ref) "--"))))
		 (emacs (concat invocation-directory invocation-name))
		 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
				       "--eval" "(byte-recompile-directory \".\" 0 'force)"))))
	    (progn (require 'elpaca)
		   (elpaca-generate-autoloads "elpaca" repo)
		   (kill-buffer buffer))
	  (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (require 'elpaca-autoloads)
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
#+end_src

** use-package

#+begin_src emacs-lisp
  (elpaca elpaca-use-package
    ;; Enable :elpaca use-package keyword.
    (elpaca-use-package-mode)
    ;; Assume :elpaca t unless otherwise specified.
    (setq elpaca-use-package-by-default t))

  (elpaca-wait)
#+end_src

* Main script
** Global variables

   These are common useful variables for getting the emacs init dir
   and the path to my personal local packages.

   #+BEGIN_SRC emacs-lisp
     (eval-and-compile
       (defconst my-init-dir (file-name-directory (or load-file-name (buffer-file-name))))
       (defconst my-site-lisp (concat my-init-dir "site-lisp/"))
       (add-to-list 'load-path my-site-lisp))
   #+END_SRC

** Custom configuration

   Move the custom configuration file outside of the init file to
   avoid blending custom configuration with the init sources.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat my-init-dir "custom-file.el"))
     (load custom-file 'no-error)
   #+END_SRC

* Theme
** Default settings

   Remove GUI garbage and increase the font size.

   #+BEGIN_SRC emacs-lisp
     (tool-bar-mode 0)
     (set-face-attribute 'default nil :height 140 :family "Source code pro")
   #+END_SRC

** Theme

#+NAME: my-themes
- tango-dark
- deeper-blue

#+begin_src emacs-lisp :var themes=my-themes
  (load-theme (intern (car (nth (random (length themes)) themes))))
#+end_src

** Mode line
*** Powerline

    I am using my own theme forked from ~powerline-default-theme~.

    #+BEGIN_SRC emacs-lisp
      (defface my-mode-line-highlight
	'((t :inherit mode-line
	     :background "gray32"))
	"Mode line face for highlighted elements")

      (defface my-mode-line-highlight-active
	'((t :inherit 'mode-line
	     :background "gray50"))
	"Mode line face for active highlighted elements")

      (defun my-powerline-theme ()
	"Setup the default mode-line."
	(interactive)
	(setq-default
	 mode-line-format
	 '("%e"
	   (:eval
	    (let* ((active (powerline-selected-window-active))
		   (mode-line-buffer-id (if active 'mode-line-buffer-id 'mode-line-buffer-id-inactive))
		   (mode-line (if active 'mode-line 'mode-line-inactive))

		   (lhs (list (powerline-raw
			       (if buffer-read-only "RO " "RW ")
			       (if (buffer-modified-p) 'my-mode-line-highlight-active 'my-mode-line-highlight)
			       'l)
			      (when (> (length (tab-bar-tabs)) 1)
				(powerline-raw (thread-last (tab-bar-tabs)
							    (assq 'current-tab)
							    (assq 'name)
							    cdr)
					       mode-line 'l))
			      (powerline-buffer-id `(mode-line-buffer-id ,mode-line) 'l)
			      (powerline-raw " " mode-line)
			      (powerline-process mode-line)
			      (powerline-narrow mode-line 'l)
			      (powerline-raw " " mode-line)
			      ))
		   (rhs (list
			 (powerline-vc mode-line 'r)
			 (powerline-raw (when flymake-mode (flymake--mode-line-counters)))
			 (unless window-system
			   (powerline-raw (char-to-string #xe0a1) mode-line 'l))
			 )))

	      (concat (powerline-render lhs)
		      (powerline-fill mode-line (powerline-width rhs))
		      (powerline-render rhs)))))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package powerline
        :config
        (setq powerline-default-separator 'bar
              powerline-display-hud nil)
        (my-powerline-theme))
    #+END_SRC

** Emojis

   ~emojify~ displays ascii emojis using images. This is both prettier
   and faster to render.

   #+begin_src emacs-lisp
     (use-package emojify
       :hook (prog-mode . emojify-mode)
       :custom (emojify-emoji-styles '(unicode)))
   #+end_src

* General UX
** Startup screen

   Use my personal startup file instead of the default one.

   #+begin_src emacs-lisp
     (setq initial-buffer-choice (expand-file-name "welcome.org" my-init-dir))
   #+end_src

** Ivy

   I use [[https://github.com/abo-abo/swiper][ivy]] instead of the basic read interface, because it has a
   good matching system and is lighter than helm.

   Ivy comes with counsel and swiper, that implements a lot of common
   Emacs commands with the Ivy interface.

   ~ivy-use-virtual-buffers~ also includes recent files and bookmarks
   in counsel's buffer list.

   ~enable-recursive-minibuffers~ is not directly related to ivy, but
   I set it up here as most of my interactions with the minibuffer
   goes through ivy. It allows opening a new minibuffer while a
   minibuffer is already opened, which I used at my job for finding
   information on my current task while creating branches, for
   example.

   #+BEGIN_SRC emacs-lisp
     (defun init/setup-ivy ()
       "Setup the ivy package."
       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (setq enable-recursive-minibuffers t))

     (use-package ivy
       :config (init/setup-ivy))

     (use-package counsel
       :after (ivy)
       :config (counsel-mode 1))

     (use-package swiper
       :after (ivy)
       :bind (("C-s" . swiper)))
   #+END_SRC

** Subword

   Using subword-mode is more convenient in PascalCase / camelCase languages

   #+begin_src emacs-lisp
     (use-package subword
       :elpaca nil
       :hook (prog-mode . subword-mode))
   #+end_src

** Prompts

   Use =y-or-n-p= instead of =yes-or-no-p= to have a smoother experience.

   #+begin_src emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+end_src

** Helpful

   [[https://github.com/Wilfred/helpful][helpful]] improves the emacs help commands with more information.

   #+begin_src emacs-lisp
     (use-package helpful
       :bind
       ("C-h k" . helpful-key)
       ("C-c C-d" . helpful-at-point)
       ("C-h C" . helpful-command)
       ("C-h o" . helpful-symbol)
       :custom
       (counsel-describe-function-function #'helpful-callable)
       (counsel-describe-variable-function #'helpful-variable))
   #+end_src

* Performances

  I use [[https://github.com/jschaf/esup][esup]] to profile my emacs startup from time to time.

  #+begin_src emacs-lisp
    (use-package esup
      :commands (esup)
      :init (setq esup-depth 0))
  #+end_src

  [[https://github.com/emacsmirror/gcmh][gcmh]] minimizes the interferences of the garbage collector with the
  user's activity. There are more details on the package's page.

  #+BEGIN_SRC emacs-lisp
    (use-package gcmh
      :config (gcmh-mode 1))
  #+END_SRC

* Editing
** French keyboard setup

   I use an AZERTY keyboard, which requires loading ~iso-transl~ to
   support all its keys.

   #+BEGIN_SRC emacs-lisp
     (use-package iso-transl
       :elpaca nil)
   #+END_SRC

** Mac special setup

   Rebind some MacOS keys to have proper super of control, alt gr,
   etc...

   #+begin_src emacs-lisp
     (when (eq system-type 'darwin)
       (setq mac-option-modifier 'meta
	     mac-right-option-modifier nil
	     mac-command-modifier 'super))
   #+end_src

** Parentheses

   Enable some core modes in order to get electric pairing and showing
   the parenthesis matching the one under the cursor.

   #+begin_src emacs-lisp
     (electric-pair-mode 1)
     (show-paren-mode 1)
   #+end_src

** Auto completion

   #+begin_src emacs-lisp
     (use-package corfu
       :custom
       (corfu-auto t)
       :init
       (global-corfu-mode))
   #+end_src

** Code checking

   #+begin_src emacs-lisp
     (use-package flymake
       :ensure
       :hook (prog-mode . flymake-mode)
       :bind ((:map flymake-mode-map
		    ("C-c ! l" . flymake-show-buffer-diagnostics)
		    ("C-c ! p" . flymake-goto-prev-error)
		    ("C-c ! n" . flymake-goto-next-error))))
   #+end_src

** Auto formatting

   I basically never want trailing whitespaces

   #+begin_src emacs-lisp
     (add-hook 'before-save-hook #'delete-trailing-whitespace)
   #+end_src

   I use [[https://editorconfig.org/][editorconfig]] as much as possible so that I can share part my
   project config with my teammates.

   #+begin_src emacs-lisp
     (use-package editorconfig
       :if (locate-library "editorconfig")
       :hook (prog-mode . editorconfig-mode))
   #+end_src

** Tree sitter

   #+begin_src emacs-lisp
     (use-package tree-sitter)
   #+end_src

   #+begin_src emacs-lisp
     (use-package tree-sitter-langs
       :hook ((php-mode . tree-sitter-hl-mode)
	      (js-mode . tree-sitter-hl-mode)
	      (typescript-mode . tree-sitter-hl-mode)))
   #+end_src

** Backups

   Stop having backups files inside my projects and committing them by
   mistake.

   #+begin_src emacs-lisp
     (setq backup-directory-alist
	   `((".*" . ,temporary-file-directory)))
     (setq auto-save-file-name-transforms
	   `((".*" ,temporary-file-directory t)))
   #+end_src

* Navigation
** imenu

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c i") #'imenu)
   #+END_SRC

** Treemacs

   [[https://github.com/Alexander-Miller/treemacs][Treemacs]] is a nice tree layout file explorer for Emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package treemacs
       :commands (treemacs))
   #+END_SRC

** ripgrep

   Ripgrep is my preferred way to search for occurences in a
   project. It is fast, and [[https://github.com/Wilfred/deadgrep][deadgrep]] offers a really nice interface
   for Emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package deadgrep
       :bind (("C-c C-s" . deadgrep)))
   #+END_SRC

* Project management
** git

   Use magit, OF COURSE

   #+begin_src emacs-lisp
     (use-package magit
       :commands (magit-status))
   #+end_src

** Projectile

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :custom
       (projectile-keymap-prefix (kbd "C-c p"))
       :config (projectile-mode))

     (use-package counsel-projectile
       :after (projectile ivy)
       :config (counsel-projectile-mode))
   #+END_SRC

* Shell
** Environment variables

   Use [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] to import shell's environment variables
   into Emacs.

   #+begin_src emacs-lisp
     (use-package exec-path-from-shell
       :config (exec-path-from-shell-initialize))
   #+end_src

** xterm-color

   [[https://github.com/atomontage/xterm-color][xterm-color]] is a replacement for ansi-color that is faster and has
   more feature.

   Here is the comint / shell-mode configuration

   #+BEGIN_SRC emacs-lisp
     (defun my-remove-ansi-from-comint ()
       "Remove ansi-color from comint filters."
       (setq comint-output-filter-functions
	   (remove 'ansi-color-process-output comint-output-filter-functions)))


     (defun my-shell-mode-config-xterm-color ()
       "Configure xterm-color for shell-mode."
       ;; Disable font-locking in this buffer to improve performance
       (font-lock-mode -1)
       ;; Prevent font-locking from being re-enabled in this buffer
       (make-local-variable 'font-lock-function)
       (setq font-lock-function (lambda (_) nil))
       (setq comint-output-filter-functions
         (remove 'ansi-color-process-output comint-output-filter-functions))
       (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)
       (setq-local comint-terminfo-terminal "xterm-256color"))
   #+END_SRC

   Then, we configure eshell:

   #+BEGIN_SRC emacs-lisp
     (defun my-eshell-before-prompt-xterm-color ()
       "Preserve text properties on eshell prompts."
       (setq xterm-color-preserve-properties t))

     (defun my-eshell-env-xterm-color ()
       "Setup eshell environment for xterm-color."
       (setenv "TERM" "xterm-256color"))
   #+END_SRC

   And compilation-mode:

   #+BEGIN_SRC emacs-lisp
     (defun my-xterm-color-configure-compilation ()
       "Setup xterm-color in compilation-mode"
       (message "Loading xterm-colors for compilation")
       (with-eval-after-load 'compile
	 (setq compilation-environment '("TERM=xterm-256color"))

	 (add-hook 'compilation-start-hook
		   (lambda (proc)
		     ;; We need to differentiate between compilation-mode buffers
		     ;; and running as part of comint (which at this point we assume
		     ;; has been configured separately for xterm-color)
		     (when (eq (process-filter proc) 'compilation-filter)
		       ;; This is a process associated with a compilation-mode buffer.
		       ;; We may call `xterm-color-filter' before its own filter function.
		       (set-process-filter
			proc
			(lambda (proc string)
			  (funcall 'compilation-filter proc
				   (xterm-color-filter string)))))))))

   #+END_SRC

   Finally, we can import and configure the package:

   #+BEGIN_SRC emacs-lisp
	  (defun my-xterm-color-init ()
	    "First setup for xterm-color."
	    (my-remove-ansi-from-comint)
	    (my-xterm-color-configure-compilation))

	  (use-package xterm-color
	    :config (my-xterm-color-init)
	    :hook ((shell-mode . my-shell-mode-config-xterm-color)
		   (eshell-mode . my-eshell-env-xterm-color)
		   (eshell-before-prompt . my-eshell-before-prompt-xterm-color)
		   (compilation-mode . my-shell-mode-config-xterm-color)))
   #+END_SRC

** vterm

   #+begin_src emacs-lisp
     (use-package vterm
       :no-require t
       :commands (vterm))
   #+end_src

* Org mode
** Basic configuration
*** Clock table indentation

    The org clock table indents its entries using the LateX symbol
    ~\emsp~, which renders badly in org buffers. I override it with my
    own indent function extracted from [[https://emacs.stackexchange.com/questions/9528/is-it-possible-to-remove-emsp-from-clock-report-but-preserve-indentation][a stackexchange discussion]].

    #+BEGIN_SRC emacs-lisp
      (defun my/org-clocktable-indent-string (level)
        (if (= level 1)
            ""
          (let ((str "+"))
            (while (> level 2)
              (setq level (1- level)
                    str (concat str "--")))
            (concat str "-> "))))
    #+END_SRC

*** Org initialization

    #+BEGIN_SRC emacs-lisp
      (defun my/init-org ()
	;; Override clock table ident function with mine
	(advice-add 'org-clocktable-indent-string :override #'my/org-clocktable-indent-string)

	;; Automatically add syntax coloration on org src blocks
	(setq org-src-fontify-natively t)

	(setq org-hide-emphasis-markers t)

	(org-babel-do-load-languages 'org-babel-load-languages
				     '((shell . t)
				       (sql . t))))

    #+END_SRC

*** Package declaration

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :elpaca nil
       :mode ("\\.org\\'" . org-mode)
       :bind (("C-c o t" . org-todo-list))
       :config (my/init-org)
       :custom
       (org-startup-folded t "Start all org documents in overview mode")
       (org-indent-mode t))
   #+END_SRC

** Mouse

#+begin_src emacs-lisp
  (use-package org-mouse
    :elpaca nil
    :after (org))
#+end_src

** Agenda

   #+BEGIN_SRC emacs-lisp
     (use-package org-agenda
       :elpaca nil
       :bind (("C-c o a" . org-agenda-list)))
   #+END_SRC

** Clock

   #+BEGIN_SRC emacs-lisp
     (use-package org-clock
       :elpaca nil
       :bind (("C-c o j" . org-clock-goto)))
   #+END_SRC

** Capture

   #+BEGIN_SRC emacs-lisp
     (use-package org-capture
       :elpaca nil
       :bind (("C-c o c" . org-capture)))
   #+END_SRC

** Async

   #+BEGIN_SRC emacs-lisp
     (use-package ob-async
       :no-require t
       :after (org))
   #+END_SRC

* Lisp

 #+begin_src emacs-lisp
   (use-package elisp-mode
     :elpaca nil
     :bind (:map emacs-lisp-mode-map
		 ("C-c C-b" . eval-buffer)))
 #+end_src

* LSP (eglot)

  #+begin_src emacs-lisp
    (defcustom my-eglot-typescript-args '()
      ""
      :safe t)

    (use-package eglot
      :bind (:map eglot-mode-map
		  ("C-c SPC" . eglot-code-actions))
      :init
      ;; Handle flymake manually to avoid conflicts with flymake-eslint
      (setq eglot-stay-out-of '(flymake))
      (add-hook 'eglot-managed-mode-hook
		#'(lambda ()
		    (add-hook 'flymake-diagnostic-functions 'eglot-flymake-backend nil)))

      ;; Advices to prevent Eglot from bugging because some LSP servers
      ;; (ts-ls) send unicode null characters. Won't be needed when Emacs
      ;; 29 is out
      ;; https://github.com/typescript-language-server/typescript-language-server/issues/559#issuecomment-1259470791
      (advice-add 'json-parse-string :around
		  (lambda (orig string &rest rest)
		    (apply orig (s-replace "\\u0000" "" string)
			   rest)))

      (advice-add 'json-parse-buffer :around
		  (lambda (oldfn &rest args)
		    (save-excursion
		      (while (search-forward "\\u0000" nil t)
			(replace-match "" nil t)))
		    (apply oldfn args)))

      ;; Unless I update my emacs, add a polyfill for project-name
      (unless (fboundp 'project-name)
	(cl-defgeneric project-name (project)
	  "A human-readable name for the project.
    Nominally unique, but not enforced."
	  (file-name-nondirectory (directory-file-name (project-root project)))))

      :config
      (add-to-list 'eglot-server-programs
		   `((js-mode typescript-mode typescriptreact-mode) .
		     ("typescript-language-server"
		      "--stdio"
		      :initializationOptions
		      (:preferences (:includeInlayParameterNameHints "none"
				     :includeInlayPropertyDeclarationTypeHints t
				     :includeInlayFunctionLikeReturnTypeHints t))))))
  #+end_src

* Sonarlint

  #+begin_src emacs-lisp
    (autoload 'sonar-visit-file-page "sonar" nil t)
  #+end_src

* Web

  Use [[http://web-mode.org/][web-mode]] for editing HTML files

  #+begin_src emacs-lisp
    (use-package web-mode
      :mode "\\.html\\'")
  #+end_src

  Use [[https://elpa.gnu.org/packages/rainbow-mode.html][rainbow-mode]] to get a preview of the hexa / rgb color we are
  reading.

  #+begin_src emacs-lisp
    (use-package rainbow-mode
      :hook (js-mode css-mode web-mode))
  #+end_src

* Javascript
** Eglot

   #+BEGIN_SRC emacs-lisp
     (use-package eglot
       :hook ((js-mode . eglot-ensure)))

     (use-package js
       :elpaca nil
       :bind (:map js-mode-map
			("M-." . xref-find-definitions)))
   #+END_SRC

** Typescript

   Setup the basic typescript-mode:

   #+BEGIN_SRC emacs-lisp
     (use-package typescript-mode
       :mode (("\\.ts\\'" . typescript-mode)
	      ("\\.tsx\\'" . typescriptreact-mode))
       :config
       ;; Eglot uses the major mode name as the languageId to send to the LSP server.
       ;; However, typescript-language-server has a different langaugeId for typescript
       (define-derived-mode typescriptreact-mode typescript-mode
	 "Typescript TSX")

       (add-to-list 'tree-sitter-major-mode-language-alist '(typescriptreact-mode . tsx)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package eglot
       :hook (typescript-mode . eglot-ensure))
   #+END_SRC

** Eslint

   #+begin_src emacs-lisp
     (autoload 'vscode-setup-flymake-eslint "vscode.el")

     (use-package flymake-eslint
       :hook ((js-mode . flymake-eslint-enable)
	      (typescript-mode . flymake-eslint-enable)
	      (typescriptreact-mode . flymake-eslint-enable)
	      (flymake-mode . vscode-setup-flymake-eslint)))
   #+end_src


   #+begin_src emacs-lisp
     (defun my-eslint-fix ()
       "Run eslint --fix on the current buffer"
       (interactive)
       (let ((default-directory (project-root (project-current))))
	 (async-shell-command (format "npx eslint --fix %s" (buffer-file-name)))))
   #+end_src

** JSON

   #+BEGIN_SRC emacs-lisp
     (use-package json-mode
       :commands (json-mode)
       :mode "\\.json\\'")
   #+END_SRC

** NVM

   Setup the correct node version when opening a JS file.

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun my-nvm-use-for ()
       (interactive)
       (condition-case error
	   (nvm-use-for-buffer)
	 (t (message "NVM error: %s" error))))

     (use-package nvm
       :hook ((js-mode json-mode typescript-mode dired-after-readin magit-mode) . my-nvm-use-for))
   #+END_SRC

** Swagger

   Setup a custom command to be able to edit yaml in multi-line comments.

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-comment
       :elpaca nil
       :after (typescript-mode)
       :bind (:map js-mode-map
	      ("C-c y" . yaml-comment-edit-at-point)
	      :map typescript-mode-map
	      ("C-c y" . yaml-comment-edit-at-point)))
   #+END_SRC

** Prettier

   Enable prettier formatting at save for all the web files.

   #+begin_src emacs-lisp
     (use-package prettier-js
       :hook ((js-mode . prettier-js-mode)
	      (typescript-mode . prettier-js-mode)
	      (web-mode . prettier-js-mode)
	      (css-mode . prettier-js-mode))
       :custom ((prettier-js-show-errors . nil)))
   #+end_src

** Node modules support

   ~add-node-modules-path~ automatically adds the node_modules bin
   folder to the path. This allows using the project tools when
   opening a file (ex: eslint, prettier).

   Make sure to add the hooks as late as possible, as some other
   packages relies on it.

   #+BEGIN_SRC emacs-lisp
     (use-package add-node-modules-path
       :hook ((js-mode . add-node-modules-path)
	      (typescript-mode . add-node-modules-path)))
   #+END_SRC

* PHP
** php-mode

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package php-mode
       :mode "\\.php\\'")
   #+END_SRC

** eglot

   This package requires [[https://github.com/felixfbecker/php-language-server][php-language-server]] to work. Follow the
   instructions on the readme to do so.

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package eglot
       :hook ((php-mode . eglot-ensure)))
   #+END_SRC
* Docker
** dockerfile-mode

   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode)
   #+END_SRC

** docker

   #+BEGIN_SRC emacs-lisp
     (use-package docker
       :commands (docker))
   #+END_SRC
* Markdown

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
      :mode "\\.md\\'")
  #+END_SRC

* YAML

  #+BEGIN_SRC emacs-lisp
    (use-package yaml-mode)
  #+END_SRC

* Android
** Helpers

   #+BEGIN_SRC emacs-lisp
     (use-package adb
       :elpaca nil
       :commands (avd-start-emulator))
   #+END_SRC

** Groovy

   This is useful for editing gradle files.

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package groovy-mode)
   #+END_SRC
* TRAMP

  Make sure the remote PATH will be properly set when connecting with
  tramp on SSH:

  #+BEGIN_SRC emacs-lisp
    (with-eval-after-load 'tramp
      (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
  #+END_SRC

* Kubernetes

  #+begin_src emacs-lisp :tangle no
    (use-package kubernetes
      :commands (kubernetes-overview))
  #+end_src

* Gettext

  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package po-mode
      :custom
      (po-auto-update-file-header nil)
      :elpaca '(po-mode :type git
			  :host github
			  :repo "stevenremot/po-mode"))
  #+END_SRC

* Swift

  #+begin_src emacs-lisp :tangle no
    (use-package swift-mode
      :mode ("\\.swift\\'" . swift-mode))
  #+end_src

* Project libs

  Load project libraries that are in the ~projects~ folder. These are
  not committed as it depends on the machine.

  #+BEGIN_SRC emacs-lisp
    (let ((projects-dir (concat my-site-lisp "projects/")))
      (message projects-dir)
      (dolist (lib (directory-files projects-dir t "\.el$"))
	(load-file lib)))
  #+END_SRC

* Cucumber

  #+begin_src emacs-lisp :tangle no
    (use-package feature-mode)
  #+end_src

* Processing

  #+begin_src emacs-lisp
    (autoload 'p5js-start-for-buffer "p5js" nil t)
  #+end_src

* Rest

  #+begin_src emacs-lisp
    (use-package restclient
      :commands restclient-mode)
  #+end_src

* GraphQL

#+begin_src emacs-lisp
  (use-package graphql-mode)
#+end_src

* Termux

  Configuration for termux environment

  #+begin_src emacs-lisp
    (when (getenv "ANDROID_DATA")
      (xterm-mouse-mode 1)
      (global-set-key (kbd "<mouse-5>") #'next-line)
      (global-set-key (kbd "<mouse-4>") #'previous-line))
  #+end_src

* Vagrant

  #+BEGIN_SRC emacs-lisp
    (use-package vagrant-tramp
      :after (tramp))
  #+END_SRC

* Local variables

# Local Variables:
# after-save-hook: org-babel-tangle
# End:
